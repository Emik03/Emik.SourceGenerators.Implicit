// SPDX-License-Identifier: MPL-2.0
namespace Emik.SourceGenerators.Implicit;

/// <summary>Contains various stringifiers for <see cref="ISymbol"/> and its derivatives.</summary>
static class SymbolStringifiers
{
    /// <summary>Creates the source of the <see cref="INamedTypeSymbol"/>.</summary>
    /// <param name="symbol">The symbol to use.</param>
    /// <param name="compilation">The compilation that contains references to ValueTuple.</param>
    /// <returns>The source of the parameter <paramref name="symbol"/>.</returns>
    [Pure]
    public static string? Source(this INamedTypeSymbol? symbol, Compilation compilation) =>
        Make(symbol, compilation) is { } initial
            ? ((ISymbol?)symbol)
           .FindPathToNull(x => x.ContainingWithoutGlobal())
           .Aggregate(initial, Next)
           .Then(HeaderAndFooter)
            : null;

    [Pure]
    static string? Make(INamedTypeSymbol? type, Compilation compilation)
    {
        const int MaxTypeParametersInValueTuple = 8;

        bool HasOverloadWithSameImplicitSignature(IMethodSymbol method)
        {
            bool ParameterEqual(IMethodSymbol x) =>
                !MethodSymbolComparer.Equal(x, method) && x.ParameterTypeSequenceEqual(method);

            return method.Parameters is [_] && type.InstanceConstructors.Any(ParameterEqual);
        }

        bool LacksRequiredValueTupleReference(IMethodSymbol method) =>
            Math.Min(method.Parameters.Length, MaxTypeParametersInValueTuple) is not 1 and var length &&
            compilation.GetTypeByMetadataName($"{nameof(System)}.{nameof(ValueTuple)}`{length}") is null;

        return type
          ?.InstanceConstructors
           .Where(type.IsRelativelyAccessible)
           .Omit(type.HasEmptyParametersOrSingleInterfaceOrSingleSelf)
           .Omit(type.HasSameParameters)
           .Omit(SymbolPredicates.HasDisablingAttribute)
           .Omit(x => x.Parameters.Debug() is [var y] ? y.Type.IsInterface() : x.Parameters.Any(x => !x.Type.CanBeGeneric()))
           .Omit(HasOverloadWithSameImplicitSignature)
           .Omit(LacksRequiredValueTupleReference)
           .Select(x => MakeMethod(type, x))
           .ToCollectionLazily() is { Count: not 0 } collection
            ? CSharp($"{collection}")
            : null;
    }

    [Pure]
    static string MakeMethod(ISymbol type, IMethodSymbol method)
    {
        var parameter = method.Parameters is [{ Name: var single }] ? single : "tuple";
        var types = method.Parameters.Select(x => x.Type).ToCollectionLazily();

        return CSharp(
            $"""
             /// <summary>
             /// Implicitly converts the parameter by creating the new instance of {type,0:_} by using the constructor
             /// <see cref="{type,0}({types,0})"/>.
             /// </summary>
             /// <param name="{parameter}">The parameter to pass onto the constructor.</param>
             /// <returns>
             /// The new instance of {type,0:_} by passing the parameter <paramref name="{parameter}"/> to the constructor
             /// <see cref="{type,0}({types,0})"/>.
             /// </returns>
             [Pure]
             public static {(types.OfType<IPointerTypeSymbol>().Any() ? "unsafe " : "")}implicit operator {type}(
                {method.Parameters:_}
             ) =>
                 new({method.Parameters});

             """
        );
    }

    [Pure]
    static string Next(string content, ISymbol symbol) =>
        content.Replace("\n", "\n    ") is var indented && symbol is ITypeSymbol type
            ? Type(type, indented)
            : Namespace(symbol, indented);

    [Pure]
    static string HeaderAndFooter(string input) => CSharp($"// <auto-generated/>\n#nullable enable\n{input}\n");

    [Pure]
    static string Type(ITypeSymbol symbol, string indented) =>
        CSharp(
            $$"""
              partial {{symbol.Keyword()}} {{symbol:_}}
              {
                  {{indented}}
              }
              """
        );

    [Pure]
    static string Namespace(ISymbol symbol, string indented) =>
        CSharp(
            $$"""
              namespace {{symbol}}
              {
                  {{indented}}
              }
              """
        );

    [Pure]
    static string CSharp([StringSyntax("C#")] this ParameterizedInterpolatedStringHandler x) => x.ToString();
}
