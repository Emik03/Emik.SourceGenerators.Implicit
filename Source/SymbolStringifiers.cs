// SPDX-License-Identifier: MPL-2.0
namespace Emik.SourceGenerators.Implicit;

/// <summary>Contains various stringifiers for <see cref="ISymbol"/> and its derivatives.</summary>
static class SymbolStringifiers
{
    /// <summary>Creates the source of the <see cref="INamedTypeSymbol"/>.</summary>
    /// <param name="symbol">The symbol to use.</param>
    /// <param name="hasValueTuple">Determines whether <see cref="ValueTuple"/> is defined.</param>
    /// <returns>The source of the parameter <paramref name="symbol"/>.</returns>
    [Pure]
    public static string? Source(this INamedTypeSymbol? symbol, bool hasValueTuple) =>
        Make(symbol, hasValueTuple) is { } initial
            ? ((ISymbol?)symbol)
           .FindPathToNull(x => x.ContainingWithoutGlobal())
           .Aggregate(initial, Next)
           .Then(HeaderAndFooter)
            : null;

    [Pure]
    static string? Make(INamedTypeSymbol? type, bool hasValueTuple)
    {
        bool HasOverloadWithSameImplicitSignature(IMethodSymbol method)
        {
            bool ParameterEqual(IMethodSymbol x) =>
                !MethodSymbolComparer.Equal(x, method) && x.ParameterTypeSequenceEqual(method);

            return method.Parameters is [_] && type.InstanceConstructors.Any(ParameterEqual);
        }

        return type
          ?.InstanceConstructors
           .Where(x => hasValueTuple || x.Parameters.Length is 1)
           .Where(type.IsRelativelyAccessible)
           .Omit(type.HasEmptyParametersOrSingleInterfaceOrSingleSelf)
           .Omit(type.HasSameParameters)
           .Omit(x => x.HasAttributeWithFullyQualifiedMetadataName(Of<AttributeGenerator>()))
           .Omit(SymbolPredicates.CanBeInImplicitOperator)
           .Omit(HasOverloadWithSameImplicitSignature)
           .Select(x => MakeMethod(type, x))
           .ToCollectionLazily() is { Count: not 0 } collection
            ? CSharp($"{collection}")
            : null;
    }

    [Pure]
    static string MakeMethod(ISymbol type, IMethodSymbol method)
    {
        var parameter = method.Parameters is [{ Name: var single }] ? single : "tuple";
        var types = method.Parameters.Select(x => x.Type).ToCollectionLazily();

        return CSharp(
            $"""
             /// <summary>
             /// Implicitly converts the parameter by creating the new instance of {type,0:_} by using the constructor
             /// <see cref="{type,0}({types,0})"/>.
             /// </summary>
             /// <param name="{parameter}">The parameter to pass onto the constructor.</param>
             /// <returns>
             /// The new instance of {type,0:_} by passing the parameter <paramref name="{parameter}"/> to the constructor
             /// <see cref="{type,0}({types,0})"/>.
             /// </returns>
             {Annotation}
             [global::System.Diagnostics.Contracts.Pure]
             public static {(types.OfType<IPointerTypeSymbol>().Any() ? "unsafe " : "")}implicit operator {type}(
                {method.Parameters:_}
             ) =>
                 new({method.Parameters});

             """
        );
    }

    [Pure]
    static string Next(string content, ISymbol symbol) =>
        content.Replace("\n", "\n    ") is var indented && symbol is ITypeSymbol type
            ? Type(type, indented)
            : Namespace(symbol, indented);

    [Pure]
    static string HeaderAndFooter(string input) => CSharp($"// <auto-generated/>\n#nullable enable\n{input}\n");

    [Pure]
    static string Type(ITypeSymbol symbol, string indented) =>
        CSharp(
            $$"""
              partial {{symbol.Keyword()}} {{symbol:_}}
              {
                  {{indented}}
              }
              """
        );

    [Pure]
    static string Namespace(ISymbol symbol, string indented) =>
        CSharp(
            $$"""
              namespace {{symbol}}
              {
                  {{indented}}
              }
              """
        );

    [Pure]
    static string CSharp([StringSyntax("C#")] this ParameterizedInterpolatedStringHandler x) => x.ToString();
}
